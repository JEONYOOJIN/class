<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>연산자</title>
</head>
<body>
    <script>
        // 산수연산자

        /*
        let num1 = 15;
        let num2 = 2;
        let result;

        result = num1 + num2;
        console.log(result); // 17

        esult = num1 - num2;
        console.log(result); // 13

        esult = num1 * num2;
        console.log(result); // 30

        esult = num1 ** num2;  // ** = 제곱(뒤에 오는 애가 '승'이 됨)
        console.log(result); // 225

        esult = num1 / num2;
        console.log(result); // 7.5

        esult = num1 % num2; // % = 나머지
        console.log(result); // 17
        */
        
        console.log(1 + 2);
        console.log(5 - 7);
        console.log(3 * 4);
        console.log(2 ** 4);
        console.log(18 / 2);
        console.log(7 % 5);

        // 사용하는 기호 -> 연산자라 함
        // 연산자 좌우에 있는 값을 피연산자라고 함
        // 연산자는 기호, 피연산자는 데이터임

        // 문자 연산
        
        const str1 = '기차가 어둠을 헤치고';
        const str2 = '은하수를 건너어어어면';
        const num = 8282;
        const str3 = '갑시다?'

        console.log(str1 + str2 + num + str3)
        // 문자 + 문자 + 숫자 + 문자
        // 결합할 때 자동으로 데이터 타입 용량이 큰쪽(string)으로 변환됨.
        // 데이터의 형태마다 바이트가 다르다.(구글에 데이터 타입 용량 검색하여 참고)



        // 대입연산자

        let num1 = 10;
        let num2 = 3;

        num1 += num2 // num1 = num1 + num2 (넘1에 대입할건데 넘1+넘2를 대입할거야)
        console.log(num1);
        // num1과 num2를 더한 값을 num1에 대입해라

        num1 -= num2 // num1 = num1 - num2 (넘1에 대입할건데 넘1-넘2를 대입할거야)
        console.log(num1);

        num1 *= num2 // num1 = num1 * num2 (넘1에 대입할건데 넘1*넘2를 대입할거야)
        console.log(num1);

        num1 /= num2 // num1 = num1 / num2 (넘1에 대입할건데 넘1/넘2를 대입할거야)
        console.log(num1);

        num1 %= num2 // num1 = num1 % num2 (넘1에 대입할건데 넘1%넘2를 대입할거야)
        console.log(num1);

        
        // 비교연산자
        // 비교연산자는 언제나 불리언 데이터를 변환함

        const A = 1;
        const B = 3;

        console.log('01', A > B); // false
        console.log('02', A < B); // true
        console.log('03', A >= B); // false
        console.log('04', A <= B); // true
        console.log('05', A == B); // false, '=='->같다, (데이터의 타입을 따지지 않음)
        console.log('06', A != B); // true (데이터의 타입을 따지지 않음), 자바에서 부정은 !을 사용
        console.log('07', A === B); // false (데이터의 타입까지 비교)
        console.log('08', A !== B); // true (데이터의 타입까지 비교)

        // 애초에 값을 비교하는 것이기 때문에 값을 먼저 비교함.
        // 07번 같은 경우 값과 타입이 똑같아야 true임. 타입이 같더라도 값이 다르니까 false임


        // 주의사항

        const int = 0;
        const bool = false;

        console.log(int == bool); // true  - 거짓값과 거짓값이기 때문에 같다고 해버림
        console.log(int === bool); // false  - 데이터의 넘버값, 불리형값으로 다르기 때문에 다르다고 함
        // 되도록 엄격한 비교를 사용해야한다.


        // 논리연산자

        // 사실 간단한데 숨은 의도가 많은애라 짜증나는 애임 - 현직자들이 힘들어함

        const C = 1;
        const D = 1;

        console.log((C >= D) || (C == D));   // true   || 이거 작성법 - 원표시 쉬프트 누르고 두번 클릭
        // C가 D보다 크거나 같다 OR C가 D와 같다. (또는)
        // 둘 중 값이 하나라도 true면, true값을 반환.

        console.log((C > D) && (C == D)); // false
        // C가 D보다 크다 AND C와 D가 같다. (그리고)
        // 둘 중 값이 하나라도 false값이 존재하면 false를 반환.

        console.log(!(C == D)); // false
        // not 연산자. 늘 반대값을 반환. 부정연산

        console.log('(1)', false || true || false); // true
        // OR 연산자는, true를 만나는 순간 뒤까지 안 감.
        // 값이 맞으면 종료시켜버림
        // OR 과 AND가 같이 있으면 OR을 먼저 계산함.

        console.log('(2)', true && ''); // true and 빈값 = 아무것도 출력하지 않음
        // AND 연산자는 앞의 조건이 참이면, AND 뒷쪽 걸 반환함
        // 이 상황에서는 빈 값을 내보내버림

        console.log('(3)', true && false && true); // false
        // 중간에 false가 들어와서 망해버린 식.
        // 앞에 조건들이 전부 다 true여야만 맨 뒤의 식을 내보내 줌.
        // 맨 뒤의 식 조차도 true여야 함.

        console.log('(4)', false || 'Iron Man'); // Iron Man
        // 거짓값이 아닌 모든 것은 참...
        // true값을 만났기 때문에 뱉은 거임.

        console.log('(5)', 0 && 'Iron Man'); // 0
        // 0을 뱉었다는 것은 0을 false 값으로 인식하는 것임
        // false를 의미하는 0을 뱉은 거임.

        console.log('(6)', 'Iron Man' || 'betman'); // Iron Man
        // OR연산자는 true를 만나면 뒤에 식까지 체크를 안함.

        console.log('(7)', !false); // true
        // not연산자. 무조건 반대 값

        console.log('(8)', !(90 > 40)); // false
        // 90은 40보다 크기 때문에 true 반대값인 false를 뱉음.

        console.log('(9)', !(90 < 40 && 40 < 90)); // true
        // (false && true) -> false -> not 반대의 값이라 했으니까 true


        // 삼항연산자

        // let age = parseInt(prompt('당신의 나이는?')); // 숫자로 변환받게 됨.
        // let setAge = 30;

        /*
        let result = a > b ? "음..나이때문에 고민이 많으시겠군요" : "오! 아직 젊으시군요"
        console.log(result);
        */
        // 물음표 앞의 식이 참일 때 첫번째 문장을 실행하고 거짓이면 2번째 문장을 실행한다.

        // let result = age > setAge ? alert('너무 걱정 마세요...') : alert('젊으시군요')
        // console.log(result);


        // 삼항 연산자 연습

        // BMI(적정몸무게 구하기), 구하는 공식 bmi = (키 - 100) * 0.9
        // 유저에게 키와 몸무게를 입력받아
        // 유저의 몸무게가 적정 몸무게보다 이상일 경우
        // '살 좀 빼세요...' 라고 알림창 띄우기
        // 미만일 경우 '살 좀 찌세요...'라고 알림창 띄우기
        // *묵시적 타입 변환 : 자바스크립트는 특적타입의 값을 기대하는 곳에
        // 다른 타입의 값이 들어오면 자동으로 타입을 변환해서 사용함.
        // 자바스크립트는 너무 자유로워서 개발자들이 코에걸면 코걸이 귀에 걸면 귀걸이라 그럴정도로 자유로운 언어임

        let userWeight = parseInt(prompt('당신의 몸무게는?'));
        let userheight = parseInt(prompt('당신의 키는?'));
        
        let result = (userheight - 100) * 0.9 < userWeight ? alert('살 좀 빼세요...') : alert('살 좀 찌세요');
        console.log(result);
    </script>
</body>
</html>